package DescriptionProcessing;

import GDLTokens.ImplicationToken;
import GDLTokens.KeyWordToken;
import GDLTokens.Token;
import SylmbolTable.Description;
import SylmbolTable.DescriptionTable;
import SylmbolTable.Fact;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;

public class Flattener
{
    /** An archive of Rule instantiations, indexed by head name. */
    private HashMap<String, ArrayList<Description>> instantiations;
    /** An archive of the rules in a game description, indexed by head name. */
    private HashMap<String, ArrayList<Description>> templates;


    /**
     * Construct a BasicPropNetFlattener for a given game.
     *
     * @param description A game description.
     */
    private ArrayList<Description> descriptionList;
    private DescriptionTable descriptionTable;

    public Flattener(ArrayList<Description> description) {
        this.descriptionList = description;
    }

    /**
     * Flattens a game description using the following process:
     * <ol>
     * <li>Records the rules in the description, and indexes them by head name.</li>
     * <li>Creates an archive of rule instantiations, initialized with
     * <tt>true</tt> rules.</li>
     * <li>Creates every instantiation of each rule in the description and
     * records the result.</li>
     * </ol>
     *
     * @return An equivalent description to the one passed into the constructor,
     * without variables.
     */
    public ArrayList<Description> flatten() {

        //descriptionList = RemoveOr.remove(descriptionList);
        templates = findTemplates(descriptionList);
        instantiations = initializeInstantiations(descriptionList);

        ArrayList<Description> flatDescription = new ArrayList<>();


        flatDescription.addAll(getInstantiations("init"));

        for ( String key : templates.keySet() ) {
            if (!key.equals("init")){
//                System.out.println(key + " -- " +flatDescription);
                flatDescription.addAll(getInstantiations(key));

            }
        }

//        System.out.println("\nIF ANYTHING IS HERE YOU WIN: " + flatDescription);
        return flatDescription;
    }

    private Description equivalentDoesRule(Description legalRule){
        ArrayList<Token> body = new ArrayList<>();
        for (Token token : legalRule.getDescription()){
            if (token.getID().equals("legal")){
                body.add(new KeyWordToken("does"));
            }
            else
                body.add(token.copy());
        }
        return new Description(body);
    }


    /**
     * Returns the list of instantiations associated with the head name
     * <tt>constant</tt>, building one first if necessary. Rules with heads
     * named <tt>legal</tt> are generated by looking up the instantiation for
     * rules with heads named <tt>does</tt> and renaming the results.
     *
     * param constant
     *            The name of the head of the rule to instantiate.
     * @return A list of instantiations.
     */
    private ArrayList<Description> getInstantiations(String constant) {
//        System.out.println(constant);
//        System.out.println("instan" + instantiations);
        if ( !instantiations.containsKey(constant) ) {
            instantiations.put(constant, new ArrayList<>());

            if ( constant.equals("does") ) {

                for ( Description rule : getInstantiations("legal") ) {
                    instantiations.get(constant).add(equivalentDoesRule(rule));
                }
            }
            else {
                System.out.println(constant + "---const----");
//                System.out.println(templates);
                for ( Description template : templates.get(constant) ) {

//                    System.out.println(template);
                    ArrayList<Description> results = new ArrayList<>();
                    instantiate(template, 1, new Substitution(), results);

                   System.out.println(results + "results ====");

                    instantiations.get(constant).addAll(results);

                }

            }
        }

        return instantiations.get(constant);
    }

    /**
     * Creates an archive of rule instantiations from a game description,
     * initialized with <tt>true</tt> rules, built using the reserved
     * <tt>base</tt> keyword.
     *
     * param description
     *            A game description.
     * @return An archive of rule instantiations, indexed by head name.
     */
    private HashMap<String, ArrayList<Description>> initializeInstantiations(ArrayList<Description> descriptionList) {

        ArrayList<Description> trues = new ArrayList<>();
        for ( Description description : descriptionList ){

            if ( description.getLeadAtom().toString().equals("base") ) {

                //System.out.println(description);
                ArrayList<Description> results = new ArrayList<>();
                expandTrue(description, 1, new ArrayList<>(), results);
                trues.addAll(results);
            }

        }
        //System.out.println(trues);
        HashMap<String, ArrayList<Description>> instantiations = new HashMap<>();
        instantiations.put("true", trues);

        return instantiations;
    }

    /**
     * Recursive method that uses a <tt>base</tt> rule to build a set of
     * <tt>true</tt> instantiations. Given a <tt>base</tt> rule of the form
     * <tt>(base name (arg1 a11 a12 ... a1n) ... (argn an1 an2 ... ann))</tt>
     * the method will return every possible combination of rules with name
     * <tt>name</tt> and args <tt>arg1</tt> through <tt>argn</tt>.
     *
     * @param base
     *            A <tt>base</tt> rule.
     * @param index
     *            The index of the rule being considered.
     * @param workingSet
     *            The list of GdlTerms built up so far.
     * @param results
     *            The list of results built up so far.
     */
    private void expandTrue(Description base, int index, ArrayList<Token> workingSet, ArrayList<Description> results) {


        if ( base.getArity() == index ) {
            //System.out.println(workingSet);
            //System.out.println(base);
            ArrayList<Token> body = new ArrayList<>(workingSet);

            results.add(new Description(base, workingSet));

        }
        else
        {

            for ( Token term : ( base.getFacts().get(index).getFact())){
                if(term.getValue() != -1 && term.getValue() != -2) {
                    workingSet.add(term);
                    expandTrue(base, index + 1, workingSet, results);
                    workingSet.remove(workingSet.size() - 1);
                }
            }
        }
    }

    /**
     * A recursive method for generating every possible instantiation of a rule.
     * Instantiations are generated by created every possible combination of
     * instantiations to the literals in the body of the rule so long as those
     * instantiations do not conflict with each other.
     *
     * @param template
     *            The rule to instantiate.
     * @param index
     *            The literal in the body currently being considered.
     * @param theta
     *            The substitution built up so far.
     * @param results
     *            The list of results built up so far.
     */

    private void instantiate(Description template, int index, Substitution theta, ArrayList<Description> results) {
        Substituter sub = new Substituter();
        Unifier uni = new Unifier();


        if ( template.getFacts().size() == index ) {

            Description d = sub.substitute(template, theta);
//            System.out.println("\ncheck1: "+d);


            boolean old = false;
            for (Description desc: results){
//                System.out.println(desc);
                if (desc.toString().equals(d.toString()))
                    old = true;
            }

            if (!old)
                results.add(d);


//            System.out.println("real result: " + results);

        }
        else {
            String check = template.getFacts().get(index).getLeadAtom().getID();

            if (!check.equals("distinct") && !check.equals("not") && !check.equals("data")){
                Fact sentence =  sub.substitute(new Fact(template.getFacts().get(index)), theta);
//                System.out.println(template.getFacts().get(index));
//                System.out.println(sentence);
                for ( Description instantiation : getInstantiations(sentence.getLeadAtom().getID()) ) {

//                    System.out.println(sentence + "--" + instantiation);


                    Substitution thetaPrime = uni.unify(sentence, instantiation);


        //                System.exit(0);
                    if ( thetaPrime!=null ) {
                        Substitution thetaCopy = theta.copy();
                        thetaCopy = thetaCopy.compose(thetaPrime);

//                        System.out.println(template +" =" + thetaCopy + "---" + index);
                        instantiate(template, index + 1, thetaCopy, results);

                    }
                }


            }

            else {
//                String arg = "";

                if (check.equals("not")) {

                    KeyWordToken t = (KeyWordToken) template.getFacts().get(index).getLeadAtom();
                    t.setId("true");
                    Fact sentence =  sub.substitute(new Fact(template.getFacts().get(index)), theta);

//                System.out.println(template.getFacts().get(index));
//                System.out.println(sentence);


                    for ( Description instantiation : getInstantiations(sentence.getLeadAtom().getID()) ) {

                        t.setId("not");


//                        System.out.println(instantiation +"tag");
                        Substitution thetaPrime = uni.unify(sentence, instantiation);
                        //System.out.println(thetaPrime);
                        //                System.exit(0);


                        if (thetaPrime != null) {
                            Substitution thetaCopy = theta.copy();
                            thetaCopy = thetaCopy.compose(thetaPrime);
                            check = "";
//                        System.out.println(template +" =" + thetaCopy + "---" + index);

//                            System.out.println(results + "1yy");
                            instantiate(template, index + 1, thetaCopy, results);

                        }
                    }
                    if (check.equals("not"))
                        instantiate(template, index + 1, theta, results);
                }

                else
                    instantiate(template, index + 1, theta, results);

                }
        }
    }

    /**
     * Records the rules in a game description, indexed by head name. Ignores
     * rules that begin with the reserved <tt>base</tt> keyword.
     *
     * param description
     *            A game description.
     * @return An archive of rules, indexed by head name.
     */
    private HashMap<String, ArrayList<Description>> findTemplates(ArrayList<Description> descriptionList){

        HashMap<String, ArrayList<Description>> templates = new HashMap<>();
        for ( Description description : descriptionList ) {

//            System.out.println(description);
            if ( !description.getLeadAtom().getID().equals("base") ) {
//                System.out.println(description);
//
                if ( !templates.containsKey(description.getLeadAtom().getID()) ){//string?
//                    System.out.println(description.getLeadAtom());
                    templates.put(description.getLeadAtom().getID(), new ArrayList<>());
                }
                templates.get(description.getLeadAtom().getID()).add(description);
            }
        }

        System.out.println(templates);
        return templates;
    }
}